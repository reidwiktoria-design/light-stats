<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#eef2f9"> 
<title>Моніторинг Світла v5.1 (Semantic Fix)</title>

<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon.PNG">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">

<style>
:root {
    --bg-card: #FFFFFF;
    --accent: #254EDB; 
    --color-on: #8DAA91;   
    --color-off: #E07A5F;
    --color-future: #E5E7EB;
    --color-neutral: #94a3b8; 
    --color-row-on: #7E9C82; 
    --color-row-off: #CC6A50;
    --text-main: #111111;
    --text-muted: #888888;
    
    --radius-l: 24px;
    --radius-m: 16px;
    
    --attack-massive-bg: #ffebee;
    --attack-massive-text: #c62828;
}

html {
    background-color: #eef2f9; 
    background-image: radial-gradient(circle at 50% 0%, #eef2f9 0%, #dce4f2 100%);
    background-attachment: fixed; background-size: cover;
    min-height: 100%; padding-top: env(safe-area-inset-top);
    -webkit-font-smoothing: antialiased;
}

body { margin: 0; padding: 0; min-height: 100svh; font-family: 'Space Grotesk', sans-serif; color: var(--text-main); }

.page { 
    max-width: 600px; width: 100%; margin: 0 auto; box-sizing: border-box;
    padding-top: calc(70px + env(safe-area-inset-top));
    padding-bottom: calc(60px + env(safe-area-inset-bottom));
    padding-left: 12px; padding-right: 12px;
}

.sticky-container {
    position: fixed; top: 0; left: 50%; transform: translateX(-50%);
    width: 100%; max-width: 600px; z-index: 1000;
    padding: 10px 12px 0 12px; padding-top: calc(10px + env(safe-area-inset-top));
    pointer-events: none;
}

.glass-bar {
    pointer-events: auto; display: flex; justify-content: space-between; align-items: center; 
    background: rgba(255,255,255,0.6); backdrop-filter: blur(20px);
    padding: 8px 8px 8px 20px; border-radius: 100px; border: 1px solid rgba(255,255,255,0.6);
    box-shadow: 0 10px 20px rgba(37, 78, 219, 0.05);
}

h1 { font-size: 14px; font-weight: 800; text-transform: uppercase; margin: 0; color: var(--accent); letter-spacing: 0.5px; }

.view-switcher { display: flex; background: rgba(0, 0, 0, 0.05); padding: 3px; border-radius: 100px; }
.view-btn { 
    border: none; background: transparent; padding: 8px 14px; 
    font-size: 11px; font-weight: 700; cursor: pointer; border-radius: 100px; color: #666; transition: 0.3s;
}
.view-btn.active { background: #FFFFFF; color: var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }

.month-nav { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; margin-bottom: 20px; }
.nav-btn { background: transparent; border: none; font-size: 24px; cursor: pointer; color: var(--accent); opacity: 0.7; }
#currentMonthDisplay { font-family: 'JetBrains Mono', monospace; font-size: 15px; font-weight: 800; text-transform: uppercase; }

.stats-overview { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px; }
.stat-card-mini {
    background: #fff; padding: 15px; border-radius: var(--radius-m);
    box-shadow: 0 4px 12px rgba(0,0,0,0.03); border: 1px solid rgba(255,255,255,1);
    display: flex; flex-direction: column; justify-content: space-between;
}
.stat-card-mini.full-width { grid-column: span 2; flex-direction: row; align-items: center; }
.scm-label { font-size: 10px; color: var(--text-muted); font-weight: 700; text-transform: uppercase; margin-bottom: 5px; }
.scm-value { font-size: 14px; font-weight: 700; color: var(--text-main); font-family: 'JetBrains Mono', monospace; }
.scm-sub { font-size: 10px; margin-top: 4px; font-weight: 600; }
.trend-up { color: var(--color-on); }
.trend-down { color: var(--color-off); }
.trend-neutral { color: var(--color-neutral); }

.status-card { 
    background: #fff; border: 2px solid var(--accent); border-radius: var(--radius-l); 
    padding: 24px; margin-bottom: 30px; box-shadow: 0 12px 30px rgba(37, 78, 219, 0.12);
    display: flex; flex-direction: column; align-items: center; text-align: center; 
}
.status-card.good { border-color: var(--color-on); box-shadow: 0 12px 30px rgba(141, 170, 145, 0.25); }
.status-card.bad { border-color: var(--color-off); box-shadow: 0 12px 30px rgba(224, 122, 95, 0.25); }
.status-icon { font-size: 12px; font-weight: 800; text-transform: uppercase; font-family: 'JetBrains Mono', monospace; margin-bottom: 8px; color: var(--text-muted); letter-spacing: 1px; }
.status-time { font-size: 56px; font-weight: 700; line-height: 1; margin: 10px 0; font-variant-numeric: tabular-nums; letter-spacing: -2px; color: var(--accent); }
.status-label { font-size: 11px; opacity: 0.6; font-family: 'JetBrains Mono', monospace; }

.day-container { 
    background: #fff; border-radius: var(--radius-m); padding: 18px; margin-bottom: 12px; 
    border: 1px solid rgba(255,255,255,1); box-shadow: 0 2px 8px rgba(0,0,0,0.02); transition: 0.2s;
    cursor: pointer; position: relative; overflow: hidden;
}
.day-container:active { transform: scale(0.99); }
.day-container.today { border: 2px solid var(--accent); background: linear-gradient(180deg, #fff 0%, #f4f7ff 100%); }
.day-container.expanded { border-color: var(--accent); box-shadow: 0 15px 40px rgba(37, 78, 219, 0.1); z-index: 10; }

.day-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.day-date { font-size: 18px; font-weight: 700; color: var(--accent); }
.day-name { font-size: 13px; color: var(--text-muted); font-weight: 600; display: flex; align-items: center; gap: 6px; }
.chevron { font-size: 10px; transition: transform 0.3s; opacity: 0.5; }
.expanded .chevron { transform: rotate(180deg); opacity: 1; color: var(--accent); }
.today-badge { font-size: 10px; font-weight: 800; background: var(--accent); color: #fff; padding: 3px 8px; border-radius: 10px; text-transform: uppercase; margin-left: 8px; }

.attack-badge {
    margin-top: 5px; font-size: 11px; font-weight: 700; color: #333; 
    background: #f4f4f4; padding: 6px 10px; border-radius: 8px; display: inline-flex; align-items: center; gap: 6px;
    border-left: 3px solid #333; margin-bottom: 10px;
}
.attack-badge.massive { background: var(--attack-massive-bg); color: var(--attack-massive-text); border-left-color: var(--attack-massive-text); }
.attack-badge.massive svg { fill: var(--attack-massive-text) !important; }
.impact-badge { display: inline-block; vertical-align: middle; font-size: 10px; color: #d32f2f; font-weight: 800; margin-left: 10px; background: #ffebee; padding: 2px 6px; border-radius: 4px; }

.timeline { height: 24px; display: flex; border-radius: 8px; overflow: hidden; background: #EDEFF2; position: relative; margin-bottom: 12px; }
.segment { height: 100%; position: relative; }
.on { background: var(--color-on); }
.off { background: var(--color-off); }
.future { background: repeating-linear-gradient(45deg, #eee, #eee 4px, #fafafa 4px, #fafafa 8px); }
.now-marker { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent); z-index: 5; box-shadow: 0 0 8px rgba(37,78,219,0.8); }

.day-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 15px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
.stat-box { display: flex; flex-direction: column; background: #f8f9fb; border-radius: 10px; padding: 10px 12px; }
.stat-label { font-size: 10px; color: #888; font-weight: 700; text-transform: uppercase; margin-bottom: 4px; }
.stat-value { font-size: 13px; color: #111; font-weight: 700; font-family: 'JetBrains Mono', monospace; }

.day-details { max-height: 0; opacity: 0; overflow: hidden; transition: 0.4s ease; }
.expanded .day-details { max-height: 500px; opacity: 1; margin-top: 15px; padding-top: 5px; border-top: 1px dashed #ddd; }
.detail-row { display: flex; justify-content: space-between; padding: 8px 12px; margin-bottom: 4px; border-radius: 6px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #fff; font-weight: 600; }

#calendarGrid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; margin-top: 10px; }
.cal-weekday { text-align: center; font-size: 10px; font-weight: 800; color: #ccc; margin-bottom: 5px; }
.cal-day { 
    aspect-ratio: 1; border-radius: 50%; position: relative; cursor: pointer; 
    display: flex; align-items: center; justify-content: center;
    background: #fff; transition: transform 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.03);
}
.cal-day:active { transform: scale(0.9); }
.cal-day.empty-data { cursor: default; opacity: 0.4; background: #f9f9f9; box-shadow: none; border: none; }
.cal-day.empty { background: transparent; cursor: default; box-shadow: none; border: none; }
.cal-inner { width: 76%; height: 76%; background: #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; color: var(--text-main); z-index: 2; }
.cal-today .cal-inner { color: var(--accent); font-weight: 800; background: #fff; }
.cal-today { box-shadow: 0 0 0 2px var(--accent); }
.cal-attack-dot { position: absolute; top: 0; right: 0; width: 14px; height: 14px; background: #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
.cal-attack-svg { width: 10px; height: 10px; fill: #d32f2f; }

#tooltip { 
    position: absolute; background: var(--accent); color: #fff; 
    padding: 8px 12px; font-family: 'JetBrains Mono', monospace; font-size: 11px; 
    border-radius: 8px; pointer-events: none; opacity: 0; z-index: 2000; 
    box-shadow: 0 5px 20px rgba(37,78,219,0.4); white-space: nowrap; transition: opacity 0.2s, transform 0.2s;
}
#tooltip.visible { opacity: 1; }
footer { margin-top: 40px; text-align: center; font-size: 10px; color: #aaa; font-family: 'JetBrains Mono', monospace; }
</style>
</head>
<body>

<div class="page">
    <div id="tooltip"></div>
    <div class="sticky-container">
        <div class="glass-bar">
            <h1>Моніторинг</h1>
            <div class="view-switcher">
                <button id="btn-list" class="view-btn active" onclick="switchView('list')">СПИСОК</button>
                <button id="btn-calendar" class="view-btn" onclick="switchView('calendar')">КАЛЕНДАР</button>
            </div>
        </div>
    </div>

    <div class="month-nav">
        <button class="nav-btn" onclick="changeMonth(-1)">←</button>
        <div id="currentMonthDisplay">...</div>
        <button class="nav-btn" onclick="changeMonth(1)">→</button>
    </div>

    <div id="statsOverview" class="stats-overview"></div>

    <div id="statusCard" class="status-card">
        <div id="statusIcon">...</div>
        <div id="statusTimer" class="status-time">--:--</div>
        <div id="statusLabel" class="status-label"></div>
    </div>

    <div id="listView"></div>
    <div id="calendarView" style="display:none;"></div>

    <footer id="footerStats"></footer>
</div>

<svg style="display:none;">
    <symbol id="icon-blast" viewBox="0 0 24 24"><path d="M12 2l2.4 7.2h7.6l-6 4.8 2.4 7.2-6-4.8-6 4.8 2.4-7.2-6-4.8h7.6z" /></symbol>
    <symbol id="icon-warn" viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></symbol>
</svg>

<script>
    let allEvents = [];
    let attacks = [];
    let currentView = 'list';
    let lastKnownEvent = null;
    let tipTimeout = null;
    let isLiveTimerRunning = false;
    
    // SVG
    const blastSvg = `<svg style="width:14px;height:14px;fill:#333;vertical-align:middle;" viewBox="0 0 24 24"><path d="M12 2l2.4 7.2h7.6l-6 4.8 2.4 7.2-6-4.8-6 4.8 2.4-7.2-6-4.8h7.6z" /></svg>`;
    const warnSvg = `<svg style="width:10px;height:10px;fill:#d32f2f;" viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`;

    function getKyivDate() { return new Date(); }

    let viewDate = getKyivDate();
    viewDate.setHours(0,0,0,0);

    async function init() {
        try {
            const [logsRes, attacksRes] = await Promise.all([
                fetch('logs.txt?t=' + Date.now()),
                fetch('attacks.txt?t=' + Date.now()).catch(() => ({ ok: false })) 
            ]);

            if(logsRes.ok) {
                const logText = await logsRes.text();
                allEvents = parseLogs(logText);
            }
            if(attacksRes.ok) {
                const attackText = await attacksRes.text();
                attacks = parseAttacks(attackText);
            }

            updateStatus(allEvents);
            render();
        } catch (e) { console.error("Init Error:", e); }
    }

    startLiveTimer();
    init();
    setInterval(init, 60000);

    function startLiveTimer() {
        if (isLiveTimerRunning) return;
        isLiveTimerRunning = true;
        setInterval(() => {
            if (lastKnownEvent) {
                const now = getKyivDate();
                const diffMs = now - lastKnownEvent.date;
                const diffMins = Math.max(0, Math.floor(diffMs / 60000));
                const timerEl = document.getElementById('statusTimer');
                if (timerEl) timerEl.innerText = formatDur(diffMins);
            }
            const markers = document.querySelectorAll('.now-marker');
            if (markers.length > 0) {
                const now = getKyivDate();
                const minsToday = now.getHours() * 60 + now.getMinutes();
                markers.forEach(m => m.style.left = (minsToday / 14.4) + '%');
            }
        }, 1000);
    }

    function parseLogs(rawText) {
        const lines = rawText.split('\n');
        const events = [];
        lines.forEach(line => {
            const isOn = line.includes('Увімкнули') || line.includes('світло є');
            const isOff = line.includes('зникло') || line.includes('немає');
            const dM = line.match(/(\d{2}\.\d{2}\.\d{2,4})/);
            const tM = line.match(/(\d{2}:\d{2})/);
            if ((isOn || isOff) && dM && tM) {
                const p = dM[1].split('.');
                const y = p[2].length === 2 ? '20'+p[2] : p[2];
                const dateStr = `${y}-${p[1]}-${p[0]}T${tM[1]}:00`;
                events.push({ date: new Date(dateStr), type: isOn ? 'ON' : 'OFF', raw: tM[1] });
            }
        });
        return events.sort((a, b) => a.date - b.date);
    }

    function parseAttacks(rawText) {
        if (!rawText) return [];
        const res = [];
        rawText.split('\n').forEach(line => {
            const p = line.split('|').map(s => s.trim());
            if (p.length >= 3) {
                res.push({ date: p[0], time: p[1], duration: parseInt(p[2]) || 2, desc: p[3] || 'Атака' });
            }
        });
        return res;
    }

    function calculateDayPotential(startMs, endMs) {
        let score = 0;
        let current = startMs;
        while(current < endMs) {
            const h = new Date(current).getHours();
            const weight = (h >= 8 && h < 23) ? 1.0 : 0.3;
            score += weight; 
            current += 60000;
        }
        return score;
    }

    function generateDays(events) {
        if (!events.length) return [];
        const days = {};
        const now = getKyivDate();
        
        let pointerDate = new Date(events[0].date);
        pointerDate.setHours(0,0,0,0);
        
        let currentState = events[0].type === 'OFF' ? 'ON' : 'OFF';
        let eventIdx = 0;
        const endLimit = new Date(); endLimit.setHours(23,59,59);

        let firstLogTime = events[0].date.getTime();

        while (pointerDate <= endLimit) {
            const k = `${pointerDate.getFullYear()}-${String(pointerDate.getMonth()+1).padStart(2,'0')}-${String(pointerDate.getDate()).padStart(2,'0')}`;
            const dStart = new Date(pointerDate);
            const dEnd = new Date(pointerDate); dEnd.setHours(23,59,59);
            const attackData = attacks.find(a => a.date === k);

            days[k] = { 
                date: dStart, segments: [], 
                totalOn: 0, totalOff: 0, 
                effectiveMinutes: 0, potentialWeight: 0, qualityIndex: 0,
                attack: attackData, hasData: false, outageCount: 0, maxOn: 0 
            };
            
            let pTime = dStart.getTime();
            let potentialStart = (dStart.getTime() < firstLogTime) ? firstLogTime : dStart.getTime();
            let potentialEnd = (dStart.toDateString() === now.toDateString()) ? now.getTime() : dEnd.getTime();
            
            if (dEnd.getTime() >= events[0].date.getTime()) {
                days[k].hasData = true;
                days[k].potentialWeight = calculateDayPotential(potentialStart, potentialEnd);

                while (eventIdx < events.length && events[eventIdx].date <= dEnd) {
                    const ev = events[eventIdx];
                    if (currentState === 'ON' && ev.type === 'OFF' && ev.date.getTime() >= dStart.getTime()) {
                        days[k].outageCount++;
                    }
                    if (ev.date.getTime() > pTime) {
                        addSeg(days[k], pTime, ev.date.getTime(), currentState, now);
                    }
                    currentState = ev.type;
                    pTime = ev.date.getTime();
                    eventIdx++;
                }
                const isToday = dStart.toDateString() === now.toDateString();
                if (isToday) {
                    if (now.getTime() > pTime) addSeg(days[k], pTime, now.getTime(), currentState, now);
                    addSeg(days[k], now.getTime(), dEnd.getTime(), 'FUTURE', now);
                } else {
                    addSeg(days[k], pTime, dEnd.getTime(), currentState, now);
                }

                let rawIndex = (days[k].potentialWeight > 0) ? (days[k].effectiveMinutes / days[k].potentialWeight) : 0;
                let penalty = Math.min(days[k].outageCount * 0.06, 0.45);
                days[k].qualityIndex = rawIndex * (1 - penalty);
            }
            pointerDate.setDate(pointerDate.getDate() + 1);
        }
        return Object.values(days).reverse();
    }

    function addSeg(day, start, end, type, now) {
        const diffMs = end - start;
        const mins = Math.floor(diffMs / 60000);
        if (mins <= 0) return;
        
        const isCurrent = (Math.abs(end - now.getTime()) < 60000) && type !== 'FUTURE';
        
        let statusText = '';
        if (type === 'ON') statusText = isCurrent ? 'СВІТЛО Є' : 'СВІТЛО БУЛО';
        else if (type === 'OFF') statusText = isCurrent ? 'СВІТЛА НЕМАЄ' : 'СВІТЛА НЕ БУЛО';
        else statusText = 'МАЙБУТНЄ';

        if (type === 'ON') { 
            day.totalOn += mins; 
            if (mins > day.maxOn) day.maxOn = mins; 

            let current = start;
            while(current < end) {
                const h = new Date(current).getHours();
                const weight = (h >= 8 && h < 23) ? 1.0 : 0.3;
                day.effectiveMinutes += weight;
                current += 60000;
            }
        }
        if (type === 'OFF') { day.totalOff += mins; } 

        day.segments.push({
            type, width: mins / 14.4,
            range: `${new Date(start).getHours()}:${String(new Date(start).getMinutes()).padStart(2,'0')} - ${new Date(end).getHours()}:${String(new Date(end).getMinutes()).padStart(2,'0')}`,
            dur: formatDur(mins),
            status: statusText
        });
    }

    function render() {
        const months = ["СІЧЕНЬ", "ЛЮТИЙ", "БЕРЕЗЕНЬ", "КВІТЕНЬ", "ТРАВЕНЬ", "ЧЕРВЕНЬ", "ЛИПЕНЬ", "СЕРПЕНЬ", "ВЕРЕСЕНЬ", "ЖОВТЕНЬ", "ЛИСТОПАД", "ГРУДЕНЬ"];
        document.getElementById('currentMonthDisplay').innerText = `${months[viewDate.getMonth()]} ${viewDate.getFullYear()}`;
        
        const allDays = generateDays(allEvents);
        renderStatsOverview(allDays);
        
        const daysInMonth = allDays.filter(d => d.date.getMonth() === viewDate.getMonth() && d.date.getFullYear() === viewDate.getFullYear());
        renderList(daysInMonth);
        renderCalendar(daysInMonth);
        
        const updateTime = getKyivDate();
        document.getElementById('footerStats').innerText = `Оновлено: ${updateTime.toLocaleDateString()} ${updateTime.toLocaleTimeString()}`;
    }

    function renderStatsOverview(days) {
        const now = getKyivDate();
        const completedDays = days.filter(d => d.hasData && d.date.toDateString() !== now.toDateString() && d.segments.every(s => s.type !== 'FUTURE'));

        if (completedDays.length < 2) { 
            document.getElementById('statsOverview').innerHTML = ''; 
            return; 
        }

        const maxComparisonDays = 7;
        const availablePairs = Math.floor(completedDays.length / 2);
        const daysToCompare = Math.min(availablePairs, maxComparisonDays);

        if (daysToCompare < 1) return;

        const currentPeriod = completedDays.slice(0, daysToCompare);
        const prevPeriod = completedDays.slice(daysToCompare, daysToCompare * 2);

        const calcWeightedAvg = (periodDays) => {
            let totalWeightedScore = 0;
            let totalWeight = 0;
            periodDays.forEach(d => {
                const w = d.potentialWeight;
                totalWeightedScore += d.qualityIndex * w;
                totalWeight += w;
            });
            return totalWeight > 0 ? (totalWeightedScore / totalWeight) : 0;
        };

        const wAvgNow = calcWeightedAvg(currentPeriod);
        const wAvgPrev = calcWeightedAvg(prevPeriod);
        
        let trend = wAvgPrev ? ((wAvgNow - wAvgPrev) / wAvgPrev) * 100 : 0;
        
        let trendIcon = '→'; 
        let trendClass = 'trend-neutral';
        let trendText = 'БЕЗ СУТТЄВИХ ЗМІН';
        
        if (Math.abs(trend) >= 5) {
            trendIcon = trend > 0 ? '↗' : '↘'; 
            trendClass = trend > 0 ? 'trend-up' : 'trend-down';
            // === SEMANTIC CHANGE: STABILITY INSTEAD OF EASE ===
            trendText = trend > 0 ? 'БІЛЬШ СТАБІЛЬНО' : 'МЕНШ СТАБІЛЬНО';
        } else {
            trend = 0; 
        }
        
        const monthDays = days.filter(d => d.date.getMonth() === viewDate.getMonth());
        const best = monthDays.reduce((p,c) => (c.totalOn > (p?.totalOn||0)) ? c : p, null);
        const worst = monthDays.reduce((p,c) => (c.totalOff > (p?.totalOff||0) && c.hasData) ? c : p, null);

        document.getElementById('statsOverview').innerHTML = `
            <div class="stat-card-mini full-width">
                <div>
                    <div class="scm-label">ІНДЕКС СТАБІЛЬНОСТІ (ЗВАЖЕНИЙ)</div>
                    <div class="scm-value ${trendClass}">${trendText} ${Math.abs(trend) < 5 ? '' : Math.abs(trend).toFixed(1) + '%'} ${trendIcon}</div>
                    <div class="scm-sub" style="color:#888">порівняння: ${daysToCompare} дн. vs ${daysToCompare} дн. (ідекс, а не години)</div>
                </div>
            </div>
            ${best ? `<div class="stat-card-mini"><div class="scm-label">НАЙКРАЩИЙ</div><div class="scm-value" style="color:var(--color-on)">${formatDur(best.totalOn)}</div><div class="scm-sub">${best.date.getDate()}.${String(best.date.getMonth()+1).padStart(2,'0')}</div></div>` : ''}
            ${worst ? `<div class="stat-card-mini"><div class="scm-label">НАЙГІРШИЙ</div><div class="scm-value" style="color:var(--color-off)">${formatDur(worst.totalOff)}</div><div class="scm-sub">${worst.date.getDate()}.${String(worst.date.getMonth()+1).padStart(2,'0')}</div></div>` : ''}
        `;
    }

    function renderList(days) {
        let html = '';
        const now = getKyivDate();
        const names = ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"];

        days.forEach((day, idx) => {
            if (day.date.getDay() === 0 && idx !== 0) html += '<div style="margin:20px 0 10px; border-bottom:1px solid #ddd; opacity:0.3"></div>';
            const isToday = day.date.toDateString() === now.toDateString();
            const dayId = `day-${day.date.getDate()}`;
            if (!day.hasData) return;

            let segs = '', dets = '<div class="day-details">';
            if (isToday) {
                const minsToday = now.getHours() * 60 + now.getMinutes();
                segs += `<div class="now-marker" style="left:${minsToday/14.4}%"></div>`;
            }

            day.segments.forEach(s => {
                const isFut = s.type === 'FUTURE';
                segs += `<div class="segment ${s.type.toLowerCase()}" style="width:${s.width}%" ${isFut ? '' : `onclick="showTip(event,'${s.status}','${s.range}','${s.dur}')"`}></div>`;
                if (!isFut) dets += `<div class="detail-row" style="background:${s.type === 'ON' ? 'var(--color-row-on)' : 'var(--color-row-off)'}"><span>${s.range}</span><span>${s.dur}</span></div>`;
            });

            let attackHtml = '';
            if (day.attack) {
                const isMassive = day.attack.desc.toLowerCase().includes('масован');
                attackHtml = `<div class="attack-badge ${isMassive ? 'massive' : ''}">${blastSvg} <span>${day.attack.desc} (${day.attack.duration}г)</span>`;
                if (day.impactDetected) attackHtml += `<span class="impact-badge">⚠️</span>`;
                attackHtml += `</div>`;
            }

            dets += '</div>';
            const total = 1440; const pct = Math.round((day.totalOn / total) * 100);

            html += `<div id="${dayId}" class="day-container ${isToday?'today':''}" onclick="toggleDay(this)">
                <div class="day-header">
                    <div style="display:flex; align-items:center;">
                        <span class="day-date">${day.date.getDate()}.${String(day.date.getMonth()+1).padStart(2,'0')}</span>
                        ${isToday ? '<span class="today-badge">СЬОГОДНІ</span>' : ''}
                    </div>
                    <div class="day-name">${names[day.date.getDay()]} <span class="chevron">▼</span></div>
                </div>
                ${attackHtml}
                <div class="timeline" style="margin-top:8px;">${segs}</div>
                <div class="day-stats-grid">
                    <div class="stat-box"><div class="stat-label">СВІТЛО БУЛО</div><div class="stat-value" style="color:var(--color-on)">${formatDur(day.totalOn)} (${pct}%)</div></div>
                    <div class="stat-box"><div class="stat-label">СВІТЛА НЕМАЄ</div><div class="stat-value" style="color:var(--color-off)">${formatDur(day.totalOff)}</div></div>
                    <div class="stat-box"><div class="stat-label">ВІДКЛЮЧЕНЬ</div><div class="stat-value">${day.outageCount}</div></div>
                    <div class="stat-box"><div class="stat-label">МАКС. СВІТЛО</div><div class="stat-value">${formatDur(day.maxOn)}</div></div>
                </div>
                ${dets}</div>`;
        });
        document.getElementById('listView').innerHTML = html || '<div style="text-align:center; padding:50px; opacity:0.3;">Немає даних</div>';
    }

    function renderCalendar(days) {
        const first = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);
        const last = new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 0);
        let offset = first.getDay(); if (offset === 0) offset = 7; offset--;
        
        let html = '<div style="display:grid; grid-template-columns:repeat(7,1fr); gap:10px; margin-bottom:5px;">';
        ["ПН","ВТ","СР","ЧТ","ПТ","СБ","НД"].forEach(d => html += `<div class="cal-weekday">${d}</div>`);
        html += '</div><div id="calendarGrid">';
        
        for (let i = 0; i < offset; i++) html += '<div class="cal-day empty"></div>';

        const dayMap = {}; days.forEach(d => dayMap[d.date.getDate()] = d);
        const now = getKyivDate();

        for (let i = 1; i <= last.getDate(); i++) {
            const data = dayMap[i];
            const isToday = (now.getDate() === i && now.getMonth() === viewDate.getMonth() && now.getFullYear() === viewDate.getFullYear());
            if (!data || !data.hasData) {
                html += `<div class="cal-day empty-data"><div class="cal-inner" style="background:transparent; color:#ccc;">${i}</div></div>`;
                continue;
            }

            let bgStyle = '';
            if (isToday) {
                const totalOnPct = (data.totalOn / 1440) * 100;
                const totalOffPct = (data.totalOff / 1440) * 100;
                const recordedPct = totalOnPct + totalOffPct;
                
                bgStyle = `background: conic-gradient(
                    var(--color-on) 0% ${totalOnPct}%, 
                    var(--color-off) ${totalOnPct}% ${recordedPct}%, 
                    var(--color-future) ${recordedPct}% 100%
                )`;
            } else {
                const total = 1440; 
                const onPercent = (data.totalOn / total) * 100;
                bgStyle = `background: conic-gradient(var(--color-on) 0% ${onPercent}%, var(--color-off) ${onPercent}% 100%)`;
            }

            let dot = ''; if (data.attack) dot = `<div class="cal-attack-dot">${warnSvg}</div>`;
            html += `<div class="cal-day ${isToday?'cal-today':''}" style="${bgStyle}" onclick="goToDay(${i})"><div class="cal-inner">${i}</div>${dot}</div>`;
        }
        document.getElementById('calendarView').innerHTML = html + '</div>';
    }

    function switchView(view) {
        currentView = view;
        document.getElementById('btn-list').classList.toggle('active', view === 'list');
        document.getElementById('btn-calendar').classList.toggle('active', view === 'calendar');
        document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
        document.getElementById('calendarView').style.display = view === 'calendar' ? 'block' : 'none';
    }

    function changeMonth(delta) { viewDate.setMonth(viewDate.getMonth() + delta); render(); }
    function toggleDay(element) {
        const isAlreadyOpen = element.classList.contains('expanded');
        document.querySelectorAll('.day-container.expanded').forEach(el => el.classList.remove('expanded'));
        if (!isAlreadyOpen) element.classList.add('expanded');
    }

    function goToDay(dayNum) {
        const el = document.getElementById(`day-${dayNum}`);
        if (el) {
            switchView('list');
            setTimeout(() => { el.scrollIntoView({behavior: 'smooth', block: 'center'}); toggleDay(el); }, 100);
        }
    }

    function updateStatus(events) {
        if (!events.length) return;
        const now = getKyivDate(); const last = events[events.length - 1]; lastKnownEvent = last;
        const diff = Math.max(0, Math.floor((now - last.date) / 60000));
        const card = document.getElementById('statusCard'); const icon = document.getElementById('statusIcon'); const timer = document.getElementById('statusTimer');
        
        if (last.type === 'ON') { 
            card.className = 'status-card good'; 
            icon.innerText = '● СВІТЛО Є'; 
            icon.style.color = 'var(--color-on)'; timer.style.color = 'var(--color-on)'; 
        } else { 
            card.className = 'status-card bad'; 
            icon.innerText = '● СВІТЛА НЕМАЄ'; 
            icon.style.color = 'var(--color-off)'; timer.style.color = 'var(--color-off)'; 
        }
        timer.innerText = formatDur(diff); document.getElementById('statusLabel').innerText = `ЗМІНА: ${last.date.toLocaleDateString()} ${last.raw}`;
    }

    function formatDur(m) { return m < 60 ? `${m}хв` : `${Math.floor(m/60)}г ${m%60}хв`; }

    function showTip(e, s, r, d) {
        e.stopPropagation();
        if (tipTimeout) clearTimeout(tipTimeout);
        const tip = document.getElementById('tooltip');
        tip.innerHTML = `<strong>${s}</strong><br>${r}<br>${d}`;
        tip.classList.add('visible');
        const screenWidth = window.innerWidth;
        const x = e.pageX; const y = e.pageY;
        if (x > screenWidth / 2) { tip.style.left = 'auto'; tip.style.right = (screenWidth - x + 10) + 'px'; tip.style.transform = 'translate(0, -100%)'; }
        else { tip.style.left = (x + 10) + 'px'; tip.style.right = 'auto'; tip.style.transform = 'translate(0, -100%)'; }
        tip.style.top = (y - 15) + 'px';
        tipTimeout = setTimeout(() => { tip.classList.remove('visible'); }, 2500);
    }
    document.addEventListener('click', () => { document.getElementById('tooltip').classList.remove('visible'); if (tipTimeout) clearTimeout(tipTimeout); });
</script>
</body>
</html>
