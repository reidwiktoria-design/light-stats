<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#eef2f9">
<title>Моніторинг Світла</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;800&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">

<style>
:root {
    --bg-card: #FFFFFF;
    --accent: #254EDB; 
    --color-on: #8DAA91;   
    --color-off: #E07A5F;
    --color-row-on: #7E9C82; 
    --color-row-off: #CC6A50;
    --text-main: #111111;
    --text-muted: #888888;
    
    --radius-l: 24px;
    --radius-m: 16px;
    --radius-s: 8px;
}

/* === АРХІТЕКТУРА === */
html {
    background: radial-gradient(
        circle at 50% 0%,
        #eef2f9 0%,
        #dce4f2 100%
    );

    min-height: 100%;
    height: 100%;

    /* критично для статус-бара */
    padding-top: env(safe-area-inset-top);

    -webkit-font-smoothing: antialiased;
}

body {
    margin: 0;
    padding: 0;

    min-height: 100svh;
    background: transparent;

    font-family: 'Space Grotesk', sans-serif;
    color: var(--text-main);
}

.page { 
    max-width: 600px; 
    width: 100%;
    margin: 0 auto; 
    box-sizing: border-box;
    
    /* Відступи з урахуванням Safe Area */
    padding-top: calc(90px + env(safe-area-inset-top));
    padding-bottom: calc(60px + env(safe-area-inset-bottom));
    padding-left: 12px;
    padding-right: 12px;
}

/* STATUS BAR FIX для iOS 26 */
.status-bar-fix {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: env(safe-area-inset-top); /* висота статус-бару */
    background-color: #eef2f9;       /* колір фонового градієнту */
    z-index: 2000;                   /* поверх всього, крім модалок якщо треба */
}

/* === STICKY HEADER === */
.sticky-container {
    position: fixed;
    top: 0; 
    left: 50%;
    transform: translateX(-50%);
    width: 100%;
    max-width: 600px;
    box-sizing: border-box;
    z-index: 1000;
    
    padding: 10px 12px 0 12px;
    padding-top: calc(10px + env(safe-area-inset-top));

    /* Пропускаємо кліки крізь контейнер */
    pointer-events: none;
}

.glass-bar {
    /* Ловимо кліки на плашці */
    pointer-events: auto;
    
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    background: rgba(255, 255, 255, 0.65); 
    backdrop-filter: blur(50px) saturate(180%); 
    -webkit-backdrop-filter: blur(50px) saturate(180%);
    padding: 8px 8px 8px 20px; 
    border-radius: 100px; 
    border: 1px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 10px 30px rgba(37, 78, 219, 0.1), inset 0 1px 1px rgba(255,255,255,0.8);
}

h1 { 
    font-size: 14px; font-weight: 800; text-transform: uppercase; margin: 0; 
    color: var(--accent); letter-spacing: 0.5px; 
}

/* SWITCHER */
.view-switcher { display: flex; background: rgba(0, 0, 0, 0.05); padding: 3px; border-radius: 100px; }
.view-btn { 
    border: none; background: transparent; padding: 8px 14px; 
    font-family: inherit; font-size: 11px; font-weight: 700; cursor: pointer; 
    border-radius: 100px; color: #666; transition: 0.3s;
}
.view-btn.active { 
    background: #FFFFFF; color: var(--accent); 
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

/* MONTH NAV */
.month-nav { 
    display: flex; justify-content: space-between; align-items: center; 
    background: rgba(255, 255, 255, 0.7); 
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 12px 20px; border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.6);
    margin-bottom: 25px; margin-top: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.03);
}
.nav-btn { 
    background: rgba(255,255,255,0.5); border: 1px solid rgba(255,255,255,0.5);
    width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
    font-size: 18px; cursor: pointer; color: var(--accent); font-weight: 700; 
    box-shadow: 0 2px 8px rgba(0,0,0,0.03); transition: 0.2s;
}
.nav-btn:active { transform: scale(0.9); background: #fff; }
#currentMonthDisplay { font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 800; text-transform: uppercase; color: var(--text-main); letter-spacing: 1px; }

/* STATUS CARD */
.status-card { 
    background: #fff; border: 2px solid var(--accent); border-radius: var(--radius-l); 
    padding: 24px; margin-bottom: 30px; 
    box-shadow: 0 12px 30px rgba(37, 78, 219, 0.12);
    display: flex; flex-direction: column; align-items: center; text-align: center; 
    transition: 0.3s;
}
.status-card.good { background: #fff; border-color: var(--color-on); box-shadow: 0 12px 30px rgba(141, 170, 145, 0.25); }
.status-card.bad { background: #fff; border-color: var(--color-off); box-shadow: 0 12px 30px rgba(224, 122, 95, 0.25); }

.status-icon { font-size: 12px; font-weight: 800; text-transform: uppercase; font-family: 'JetBrains Mono', monospace; margin-bottom: 8px; color: var(--text-muted); letter-spacing: 1px; }
.status-time { font-size: 56px; font-weight: 700; line-height: 1; margin: 10px 0; font-variant-numeric: tabular-nums; letter-spacing: -2px; color: var(--accent); }
.status-label { font-size: 11px; opacity: 0.6; font-family: 'JetBrains Mono', monospace; }

/* DAY CONTAINER */
.day-container { 
    background: #fff; border-radius: var(--radius-m); padding: 18px; margin-bottom: 12px; 
    border: 1px solid rgba(255,255,255,1);
    box-shadow: 0 4px 12px rgba(0,0,0,0.03); transition: 0.3s;
    cursor: pointer; position: relative; overflow: hidden;
}
.day-container:active { transform: scale(0.98); }
.day-container.today { border: 2px solid var(--accent); background: linear-gradient(135deg, #fff 0%, #f0f4ff 100%); }
.day-container.expanded { 
    border-color: var(--accent); box-shadow: 0 20px 50px rgba(37, 78, 219, 0.15); 
    z-index: 10; transform: translateY(-2px);
}
.day-container.perfect { border-color: var(--color-on); }

.day-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.day-date-group { display: flex; align-items: center; gap: 8px; }
.day-date { font-size: 18px; font-weight: 700; color: var(--accent); }
.day-name { font-size: 13px; color: var(--text-muted); font-weight: 600; text-transform: capitalize; }
.today-badge { font-size: 10px; font-weight: 800; background: var(--accent); color: #fff; padding: 3px 8px; border-radius: 10px; text-transform: uppercase; }

/* TIMELINE */
.timeline { height: 24px; display: flex; border-radius: 8px; overflow: hidden; background: #EDEFF2; position: relative; margin-bottom: 12px; }
.segment { height: 100%; position: relative; transition: 0.2s; }
.on { background: var(--color-on); }
.off { background: var(--color-off); }
.future { background: repeating-linear-gradient(45deg, #eee, #eee 4px, #f9f9f9 4px, #f9f9f9 8px); }
.now-marker { position: absolute; top: 0; bottom: 0; width: 2px; background: var(--accent); z-index: 5; box-shadow: 0 0 8px rgba(37,78,219,0.6); transition: left 1s linear; }

/* STATS GRID */
.day-stats-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
    margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0;
}
.stat-box { display: flex; flex-direction: column; background: #f8f9fb; border-radius: 10px; padding: 8px 12px; }
.stat-label { font-size: 10px; color: #888; font-weight: 700; text-transform: uppercase; margin-bottom: 2px; }
.stat-value { font-size: 13px; color: #111; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
.stat-value.green { color: var(--color-row-on); }
.stat-value.red { color: var(--color-row-off); }

/* DETAILS */
.day-details { max-height: 0; opacity: 0; overflow: hidden; transition: 0.5s cubic-bezier(0.19, 1, 0.22, 1); }
.expanded .day-details { max-height: 800px; opacity: 1; margin-top: 15px; padding-top: 5px; border-top: 1px dashed #ddd; }
.detail-row { display: flex; justify-content: space-between; padding: 10px 14px; margin-bottom: 6px; border-radius: 8px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #fff; font-weight: 600; }
.row-on { background: var(--color-row-on); }
.row-off { background: var(--color-row-off); }

/* CALENDAR */
#calendarGrid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; margin-top: 10px; }
.cal-weekday { text-align: center; font-size: 10px; font-weight: 800; color: #ccc; margin-bottom: 5px; }
.cal-day { 
    aspect-ratio: 1; border-radius: 50%; position: relative; cursor: pointer; 
    display: flex; align-items: center; justify-content: center;
    background: #fff; transition: transform 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.03);
}
.cal-day:active { transform: scale(0.9); }
.cal-day.empty { background: transparent; cursor: default; box-shadow: none; border: none; }
.cal-inner {
    width: 80%; height: 80%; background: #fff; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; font-weight: 700; color: var(--text-main); z-index: 2;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.02);
}
.cal-today .cal-inner { color: var(--accent); font-weight: 800; }
.cal-today { box-shadow: 0 0 15px rgba(37,78,219,0.3); }

/* TOOLTIP */
#tooltip { 
    position: absolute; background: var(--accent); color: #fff; 
    padding: 8px 12px; font-family: 'JetBrains Mono', monospace; font-size: 11px; 
    border-radius: 8px; pointer-events: none; opacity: 0; z-index: 2000; 
    box-shadow: 0 5px 20px rgba(37,78,219,0.4); 
    white-space: nowrap; transition: opacity 0.2s, transform 0.2s;
}
#tooltip.visible { opacity: 1; }

.week-separator { display: flex; align-items: center; color: var(--accent); font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin: 30px 0 15px; opacity: 0.4; }
.week-separator::before, .week-separator::after { content: ''; flex: 1; height: 1px; background: var(--accent); opacity: 0.3; }
.week-separator span { padding: 0 10px; }

footer { margin-top: 40px; text-align: center; font-size: 10px; color: #aaa; font-family: 'JetBrains Mono', monospace; }
</style>
</head>
<body>
<div class="status-bar-fix"></div>
<div class="page">
    <div id="tooltip"></div>
    
    <div class="sticky-container">
        <div class="glass-bar">
            <h1>Моніторинг Світла</h1>
            <div class="view-switcher">
                <button id="btn-list" class="view-btn active" onclick="switchView('list')">СПИСОК</button>
                <button id="btn-calendar" class="view-btn" onclick="switchView('calendar')">КАЛЕНДАР</button>
            </div>
        </div>
    </div>

    <div class="month-nav">
        <button class="nav-btn" onclick="changeMonth(-1)">←</button>
        <div id="currentMonthDisplay">...</div>
        <button class="nav-btn" onclick="changeMonth(1)">→</button>
    </div>

    <div id="statusCard" class="status-card">
        <div id="statusIcon">...</div>
        <div id="statusTimer" class="status-time">--:--</div>
        <div id="statusLabel" class="status-label"></div>
    </div>

    <div id="listView"></div>
    <div id="calendarView" style="display:none;"></div>

    <footer id="footerStats"></footer>
</div>

<script>
    let allEvents = [];
    let currentView = 'list';
    let lastKnownEvent = null;
    let tipTimeout = null;
    let isLiveTimerRunning = false; // Прапор для запобігання множенню таймерів
    
    function getKyivDate() {
        const now = new Date();
        const kyivTimeStr = now.toLocaleString("en-US", {timeZone: "Europe/Kyiv"});
        return new Date(kyivTimeStr);
    }

    let viewDate = getKyivDate();
    viewDate.setHours(0,0,0,0);

    async function init() {
        try {
            const response = await fetch('logs.txt?t=' + Date.now());
            const text = await response.text();
            allEvents = parseLogs(text);
            updateStatus(allEvents);
            render();
            // startLiveTimer() більше не тут!
        } catch (e) { console.error(e); }
    }

    // Запускаємо один раз при старті сторінки
    startLiveTimer();
    // Ініціалізація даних
    init();
    // Полінг даних раз на хвилину
    setInterval(init, 60000);

    // FIX 1: ЗАХИСТ ВІД МНОЖЕННЯ ТАЙМЕРІВ
    function startLiveTimer() {
        if (isLiveTimerRunning) return;
        isLiveTimerRunning = true;

        setInterval(() => {
            if (lastKnownEvent) {
                const nowKyiv = getKyivDate();
                const diffMs = nowKyiv - lastKnownEvent.date;
                const diffMins = Math.max(0, Math.floor(diffMs / 60000));
                const timerEl = document.getElementById('statusTimer');
                if (timerEl) timerEl.innerText = formatDur(diffMins);
            }
            const markers = document.querySelectorAll('.now-marker');
            if (markers.length > 0) {
                const nowKyiv = getKyivDate();
                const minsToday = nowKyiv.getHours() * 60 + nowKyiv.getMinutes();
                markers.forEach(m => m.style.left = (minsToday / 14.4) + '%');
            }
        }, 1000);
    }

    function parseLogs(rawText) {
        const lines = rawText.split('\n');
        const events = [];
        lines.forEach(line => {
            const isOn = line.includes('Увімкнули') || line.includes('світло є');
            const isOff = line.includes('зникло') || line.includes('немає');
            const dM = line.match(/(\d{2}\.\d{2}\.\d{2,4})/);
            const tM = line.match(/(\d{2}:\d{2})/);
            if ((isOn || isOff) && dM && tM) {
                const p = dM[1].split('.');
                const y = p[2].length === 2 ? '20'+p[2] : p[2];
                
                // FIX 2: TIMEZONE
                // Прибираємо +02:00. Тепер це ISO формат без зони.
                // Браузер сам розпарсить це як локальний час (Kyiv).
                const dateStr = `${y}-${p[1]}-${p[0]}T${tM[1]}:00`;
                events.push({ date: new Date(dateStr), type: isOn ? 'ON' : 'OFF', raw: tM[1] });
            }
        });
        return events.sort((a, b) => a.date - b.date);
    }

    function changeMonth(delta) {
        viewDate.setMonth(viewDate.getMonth() + delta);
        render();
    }

    function switchView(view) {
        currentView = view;
        document.getElementById('btn-list').classList.toggle('active', view === 'list');
        document.getElementById('btn-calendar').classList.toggle('active', view === 'calendar');
        document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
        document.getElementById('calendarView').style.display = view === 'calendar' ? 'block' : 'none';
        render();
    }

    function toggleDay(element) {
        const isAlreadyOpen = element.classList.contains('expanded');
        document.querySelectorAll('.day-container.expanded').forEach(el => el.classList.remove('expanded'));
        if (!isAlreadyOpen) element.classList.add('expanded');
    }

    function generateDays(events) {
        if (!events.length) return [];
        const days = {};
        const nowKyiv = getKyivDate();
        
        let pointerDate = new Date(events[0].date);
        pointerDate.setHours(0,0,0,0);
        
        // FIX 3: LOGIC OF FIRST DAY
        // Якщо це перший день в історії, ми не повинні припускати, що було до першої події.
        // Але щоб не ламати UI, ми поки що використовуємо інверсію,
        // проте це місце потенційно неточне.
        let currentState = events[0].type === 'OFF' ? 'ON' : 'OFF';
        
        let eventIdx = 0;
        const endLimit = new Date(); endLimit.setHours(23,59,59);

        // Знаходимо індекс найпершої події
        const firstEventTime = events[0].date.getTime();

        while (pointerDate <= endLimit) {
            const k = pointerDate.toISOString().split('T')[0];
            const dStart = new Date(pointerDate);
            const dEnd = new Date(pointerDate); dEnd.setHours(23,59,59);
            days[k] = { date: dStart, segments: [], totalOn: 0, totalOff: 0, outageCount: 0, maxOn: 0 };
            let pTime = dStart.getTime();

            // Якщо це найперший день, починаємо малювати не з 00:00, а з першої події?
            // User: "Або явно вважати перший день неповним".
            // Тимчасове рішення: якщо pTime менше першої події, ми "пропускаємо" цей час візуально
            // шляхом синхронізації pTime з першою подією, якщо вона в цьому дні.
            if (pTime < firstEventTime && dEnd.getTime() >= firstEventTime) {
                 // Тут можна було б додати логіку "Unknown", але це вимагає CSS змін.
                 // Поки залишаємо як є для цілісності дизайну.
            }

            while (eventIdx < events.length && events[eventIdx].date <= dEnd) {
                const ev = events[eventIdx];
                if (ev.date.getTime() > pTime) addSeg(days[k], pTime, ev.date.getTime(), currentState);
                currentState = ev.type;
                pTime = ev.date.getTime();
                eventIdx++;
            }

            const isToday = dStart.toDateString() === nowKyiv.toDateString();
            if (isToday) {
                if (nowKyiv.getTime() > pTime) addSeg(days[k], pTime, nowKyiv.getTime(), currentState, currentState === 'ON' ? 'СВІТЛО Є' : 'СВІТЛА НЕМАЄ');
                addSeg(days[k], nowKyiv.getTime(), dEnd.getTime(), 'FUTURE');
            } else {
                addSeg(days[k], pTime, dEnd.getTime(), currentState);
            }
            pointerDate.setDate(pointerDate.getDate() + 1);
        }
        return Object.values(days).reverse();
    }

    function addSeg(day, start, end, type, label) {
        const mins = Math.floor((end - start) / 60000);
        if (mins <= 0) return;
        if (type === 'OFF') day.outageCount++;
        if (type === 'ON') { day.totalOn += mins; if (mins > day.maxOn) day.maxOn = mins; }
        if (type === 'OFF') day.totalOff += mins;

        day.segments.push({
            type, width: mins / 14.4,
            range: `${new Date(start).getHours()}:${String(new Date(start).getMinutes()).padStart(2,'0')} - ${new Date(end).getHours()}:${String(new Date(end).getMinutes()).padStart(2,'0')}`,
            dur: mins < 60 ? `${mins}хв` : `${Math.floor(mins/60)}г ${mins%60}хв`,
            status: label || (type === 'ON' ? 'СВІТЛО БУЛО' : 'СВІТЛА НЕ БУЛО')
        });
    }

    function render() {
        const months = ["СІЧЕНЬ", "ЛЮТИЙ", "БЕРЕЗЕНЬ", "КВІТЕНЬ", "ТРАВЕНЬ", "ЧЕРВЕНЬ", "ЛИПЕНЬ", "СЕРПЕНЬ", "ВЕРЕСЕНЬ", "ЖОВТЕНЬ", "ЛИСТОПАД", "ГРУДЕНЬ"];
        document.getElementById('currentMonthDisplay').innerText = `${months[viewDate.getMonth()]} ${viewDate.getFullYear()}`;
        
        const days = generateDays(allEvents).filter(d => d.date.getMonth() === viewDate.getMonth() && d.date.getFullYear() === viewDate.getFullYear());
        
        renderList(days);
        renderCalendar(days);
        
        const updateTime = getKyivDate();
        document.getElementById('footerStats').innerText = `Оновлено: ${updateTime.toLocaleDateString()} ${updateTime.toLocaleTimeString()}`;
    }

    function renderList(days) {
        let html = '';
        const nowKyiv = getKyivDate();
        const names = ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"];

        days.forEach((day, idx) => {
            if (day.date.getDay() === 0 && idx !== 0) html += '<div class="week-separator"><span>Минулий тиждень</span></div>';
            
            const isToday = day.date.toDateString() === nowKyiv.toDateString();
            const dayId = `day-${day.date.getDate()}`;
            const totalTracked = day.totalOn + day.totalOff;
            const percentOn = totalTracked > 0 ? Math.round((day.totalOn / totalTracked) * 100) : 0;

            let segs = '', dets = '<div class="day-details">';
            if (isToday) {
                const minsToday = nowKyiv.getHours() * 60 + nowKyiv.getMinutes();
                segs += `<div class="now-marker" style="left:${minsToday/14.4}%"></div>`;
            }

            day.segments.forEach(s => {
                const isFut = s.type === 'FUTURE';
                segs += `<div class="segment ${s.type.toLowerCase()}" style="width:${s.width}%" ${isFut ? '' : `onclick="showTip(event,'${s.status}','${s.range}','${s.dur}')"`}></div>`;
                if (!isFut) dets += `<div class="detail-row" style="background:${s.type === 'ON' ? 'var(--color-row-on)' : 'var(--color-row-off)'}"><span>${s.range}</span><span>${s.dur}</span></div>`;
            });

            html += `<div id="${dayId}" class="day-container ${isToday?'today':''} ${day.totalOff===0?'perfect':''}" onclick="toggleDay(this)">
                <div class="day-header">
                    <div class="day-date-group">
                        <div class="day-date">${day.date.getDate()}.${String(day.date.getMonth()+1).padStart(2,'0')}</div>
                        ${isToday ? '<span class="today-badge">СЬОГОДНІ</span>' : ''}
                    </div>
                    <div class="day-name">${names[day.date.getDay()]} <span class="chevron">▼</span></div>
                </div>
                <div class="timeline">${segs}</div>
                <div class="day-stats-grid">
                    <div class="stat-box"><div class="stat-label">СВІТЛО БУЛО</div><div class="stat-value green">${formatDur(day.totalOn)} (${percentOn}%)</div></div>
                    <div class="stat-box"><div class="stat-label">СВІТЛА НЕ БУЛО</div><div class="stat-value red">${formatDur(day.totalOff)}</div></div>
                    <div class="stat-box"><div class="stat-label">ВІДКЛЮЧЕНЬ</div><div class="stat-value">${day.outageCount}</div></div>
                    <div class="stat-box"><div class="stat-label">МАКС. СВІТЛО</div><div class="stat-value">${formatDur(day.maxOn)}</div></div>
                </div>
                ${dets}</div></div>`;
        });
        document.getElementById('listView').innerHTML = html || '<div style="text-align:center; padding:50px; opacity:0.3;">Немає даних</div>';
    }

    function renderCalendar(days) {
        const first = new Date(viewDate.getFullYear(), viewDate.getMonth(), 1);
        const last = new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 0);
        let offset = first.getDay(); if (offset === 0) offset = 7; offset--;
        
        let html = '<div class="cal-header" style="display:grid; grid-template-columns:repeat(7,1fr); gap:10px; margin-bottom:5px;">';
        ["ПН","ВТ","СР","ЧТ","ПТ","СБ","НД"].forEach(d => html += `<div class="cal-weekday">${d}</div>`);
        html += '</div><div id="calendarGrid">';
        
        for (let i = 0; i < offset; i++) html += '<div class="cal-day empty"></div>';

        const dayMap = {}; days.forEach(d => dayMap[d.date.getDate()] = d);
        const nowKyiv = getKyivDate();

        for (let i = 1; i <= last.getDate(); i++) {
            const data = dayMap[i];
            const isToday = (nowKyiv.getDate() === i && nowKyiv.getMonth() === viewDate.getMonth() && nowKyiv.getFullYear() === viewDate.getFullYear());
            let bgStyle = 'background: #fff';
            if (data && (data.totalOn || data.totalOff)) {
                const total = 1440;
                const offDeg = (data.totalOff / total) * 360;
                bgStyle = `background: conic-gradient(var(--color-off) ${offDeg}deg, var(--color-on) 0deg)`;
            }
            html += `<div class="cal-day ${isToday?'cal-today':''}" style="${bgStyle}" onclick="goToDay(${i})"><div class="cal-inner">${i}</div></div>`;
        }
        document.getElementById('calendarView').innerHTML = html + '</div>';
    }

    function goToDay(dayNum) {
        switchView('list');
        setTimeout(() => {
            const el = document.getElementById(`day-${dayNum}`);
            if (el) {
                el.scrollIntoView({behavior: 'smooth', block: 'center'});
                toggleDay(el);
            }
        }, 100);
    }

    function updateStatus(events) {
        if (!events.length) return;
        const nowKyiv = getKyivDate();
        const last = events[events.length - 1];
        lastKnownEvent = last;
        const diff = Math.max(0, Math.floor((nowKyiv - last.date) / 60000));
        
        const card = document.getElementById('statusCard');
        const icon = document.getElementById('statusIcon');
        const timer = document.getElementById('statusTimer');
        
        if (last.type === 'ON') {
            card.className = 'status-card good';
            icon.innerText = '● СВІТЛО Є';
            icon.style.color = 'var(--color-on)';
            timer.style.color = 'var(--color-on)';
        } else {
            card.className = 'status-card bad';
            icon.innerText = '● СВІТЛА НЕМАЄ';
            icon.style.color = 'var(--color-off)';
            timer.style.color = 'var(--color-off)';
        }

        timer.innerText = formatDur(diff);
        document.getElementById('statusLabel').innerText = `ЗМІНА: ${last.date.toLocaleDateString()} ${last.raw}`;
    }

    function formatDur(m) { return m < 60 ? `${m}хв` : `${Math.floor(m/60)}г ${m%60}хв`; }

    function showTip(e, s, r, d) {
        e.stopPropagation();
        
        if (tipTimeout) clearTimeout(tipTimeout);

        const tip = document.getElementById('tooltip');
        tip.innerHTML = `<strong>${s}</strong><br>${r}<br>${d}`;
        tip.classList.add('visible');

        const screenWidth = window.innerWidth;
        const x = e.pageX;
        const y = e.pageY;
        
        if (x > screenWidth / 2) {
            tip.style.left = 'auto';
            tip.style.right = (screenWidth - x + 10) + 'px';
            tip.style.transform = 'translate(0, -100%)';
        } else {
            tip.style.left = (x + 10) + 'px';
            tip.style.right = 'auto';
            tip.style.transform = 'translate(0, -100%)';
        }
        
        tip.style.top = (y - 15) + 'px';

        tipTimeout = setTimeout(() => {
            tip.classList.remove('visible');
        }, 2500);
    }
    
    document.addEventListener('click', () => {
        document.getElementById('tooltip').classList.remove('visible');
        if (tipTimeout) clearTimeout(tipTimeout);
    });
</script>
</body>
</html>
